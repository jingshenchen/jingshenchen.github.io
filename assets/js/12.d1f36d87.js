(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{372:function(e,l,t){"use strict";t.r(l);var o=t(45),a=Object(o.a)({},(function(){var e=this,l=e.$createElement,t=e._self._c||l;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"flex布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flex布局"}},[e._v("#")]),e._v(" flex布局")]),e._v(" "),t("p",[e._v("1.主轴与交叉轴。"),t("em",[e._v("水平的不一定是主轴")])]),e._v(" "),t("p",[e._v("2.弹性容器中所有子元素称为 “弹性元素”，弹性元素永远沿主轴排列")]),e._v(" "),t("p",[e._v("3.弹性元素也可以设置成弹性容器，一个元素既可以是弹性容器也可以是弹性元素。")]),e._v(" "),t("p",[e._v("4.flex-flow相当于规定了flex布局的“工作流(flow)”,flex-flow = flex-drection + flex-wrap")]),e._v(" "),t("blockquote",[t("h3",{attrs:{id:"沿主轴的排列处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#沿主轴的排列处理"}},[e._v("#")]),e._v(" 沿主轴的排列处理")]),e._v(" "),t("blockquote",[t("p",[e._v("主轴排不下，通过设置flex-wrap: nowrap | wrap | wrap-reverse可使得主轴上的元素不折行、折行、反向折行。")]),e._v(" "),t("blockquote",[t("p",[e._v("1.默认是nowrap不折行。")]),e._v(" "),t("p",[e._v("2.wrap折行，顾名思义就是另起一行.")]),e._v(" "),t("p",[e._v("3.wrap-reverse反向折行，是从容器底部开始的折行，但每行元素之间的排列仍保留正向。")])])]),e._v(" "),t("h3",{attrs:{id:"元素弹性伸缩应对"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元素弹性伸缩应对"}},[e._v("#")]),e._v(" 元素弹性伸缩应对")]),e._v(" "),t("blockquote",[t("p",[e._v("当*flex-wrap: nowrap;*时,容器宽度剩余、不够分")]),e._v(" "),t("blockquote",[t("p",[e._v("1.flex-shrink: 缩小比例（容器宽度<元素总宽度时如何收缩）")]),e._v(" "),t("blockquote",[t("p",[e._v("flex-shrink默认为1，当不够分配时，元素都将等比例缩小，占满整个宽度")])]),e._v(" "),t("p",[e._v("2.flex-grow:放大比例 "),t("strong",[e._v("（容器无多余宽度则不生效）")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[t("p",[e._v("默认为0，剩余宽度默认不进行分配")])]),e._v(" "),t("li",[t("p",[e._v("指定flex-grow为大于零的值，实现容器剩余宽度的分配比例设置。")])])])])])]),e._v(" "),t("h3",{attrs:{id:"刚性尺寸-设置元素尺寸除了width和height以外-flex还提供了一个flex-basis属性。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#刚性尺寸-设置元素尺寸除了width和height以外-flex还提供了一个flex-basis属性。"}},[e._v("#")]),e._v(" 刚性尺寸--设置元素尺寸除了width和height以外，flex还提供了一个flex-basis属性。")]),e._v(" "),t("blockquote",[t("p",[e._v("flex-basis设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在flex-grow和flex-shrink生效前的尺寸。")]),e._v(" "),t("blockquote",[t("p",[e._v("1.与width和height的区别")]),e._v(" "),t("blockquote",[t("p",[e._v("width: 0 ---- 完全没显示\nflex-basis: 0 --- 根据内容撑开\n2.两者非0 , flex-basis优先级高\n3.flex-basis --- 有width则由width决定，没有则由内容决定。\n4.flex-basis != width")])])])]),e._v(" "),t("h3",{attrs:{id:"复合属性-flex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复合属性-flex"}},[e._v("#")]),e._v(" 复合属性 flex")]),e._v(" "),t("blockquote",[t("p",[e._v("flex = flex-grow + flex-shrink + flex-basis")]),e._v(" "),t("blockquote",[t("p",[e._v("flex: 1; = flex: 1 1 0%;")])]),e._v(" "),t("blockquote",[t("p",[e._v("flex: 2; = flex: 2 1 0%;")])]),e._v(" "),t("blockquote",[t("p",[e._v("flex: auto; = flex: 1 1 auto;")])]),e._v(" "),t("blockquote",[t("p",[e._v("flex: none; = flex: 0 0 auto; // 常用于固定尺寸 不伸缩")])]),e._v(" "),t("blockquote",[t("p",[e._v("flex:1;和flex:auto 的区别")]),e._v(" "),t("blockquote",[t("p",[e._v("flex-basis是指定初始尺寸，当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸；相反当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。")])])])])])])}),[],!1,null,null,null);l.default=a.exports}}]);